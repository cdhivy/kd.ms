---
title: No, react server components won't make your life simpler
description: Fullstack development, or rather isomorphic development, isn't as simple as they say.
author: Stephan Meijer
date: 2023-05-25
---

Server doesn't. Sure, your react components will look simpler, but your mental mode shouldn't. There's less context in the component, but more so in your head. Server and client, are not the same. Thinking they are, is just foolish.

Let's make clear that this post isn't a rant about server components. I have nothing against those, and I'm not against full stack development either. What I am against, is the false claim that moving parts of our code to the server, would make the job of a frontend developer easier.

I've decided to write down a few thoughts, in response to various claims that the recistance against server components is no different from the anti-JSX crowd years ago. I can tell you, this recent shift is nothing like that. It's not even close to a change in syntax or the need to adapt your mental model. It's also not just the fullstack aspect that makes it hard, it's the isomorphic aspect.

## Isomorphic Development: Bridging the network

Let's clear out the first misconception. Frameworks like Next.js and Remix let you write server and client code neatly together, and you'll spawn your environment with a single `npm run dev` command. That doesn't mean that it's one environment tho.

There's still a server, and still a client/browser bundle. In Next the server is code generated by extracting methods like `getServerSideProps` or the new functions decorated with `'use server'` , and in Remix it's functions like `loader` and `action` that run exclusively on the server. Client side code runs in the browser, but depending on your implementation it might also run on the server. Let that last one sink in for a moment. That's what this writing is about.

The thing to understand is that the build tools separate your server and client logic, and run each in their own environment. Server code on the server, client code in the browser, and sometimes, but not always, client code on the server. That, is what makes it _not easier_.

With this paradime shift, we're not asking frontend developers to render their code on the server, we're asking them to write code that's runs safely, performantly, in both environments.

## Debugging: Juggling Two Environments

With code split between the frontend and backend, you're suddenly managing two separate environments. It means watching two debuggers hitting breakpoints, each with its own context. Or for the console.loggers amongst us, you'll now have log statements in two consoles.

Also remember that your component might render twice. Once in the context of the server, and once in the context of the client. Might, because Next.js took a different direction than Remix. In Remix, your component will render twice. Once on the server, and then on the client during hydration (bind js handlers to make interactive). Next.js chose the route of not supporting state / interactivity on server components, so no hydration/rerender is needed there.

## Security: Protecting Boundaries

Fullstack developers must guard against data leaks and breaches. The server has access to senstive information that clients shouldn't have. You'll now have to think about how to get those properties safely to the client.

Did you once store a variable on the module scope (out of your react component) as a form of cache between renders? Move that component from 'use client' to 'use server' during a refactor, and you'll leak information between users.

It might not be hard to fix, but it's an easy bug to introduce when your build tool decides where to run the code. Something to keep in mind and be aware of. At any time.

## Performance: The Dual Nature

Performance behaves differently on the client and server. On the client, speed matters and we avoid browser bottlenecks. To use our time efficient, we often work under the principle "you don't run the function a thousand times, so fast is fast enough". Well, move that function from the client to the server, and scalability takes center stage. Functions that once ran only a couple of times, now run a couple times on every user request.

And remember, Node.js is single threaded. All sync code that runs on the server, blocks other requests being made. In the browser you don't notice a 10ms delay, on your server, it can cause requests to queue up.

## Data Querying: Bridging The Gap

Querying data is a joint effort. Frontend make API calls, while backend tackles databases. Fullstack developers must master database performance, query optimizations, and indexing. Don't forget about rate limitting challenges when server interacts with external APIs. Where the client would have made a handfull requests to an API from thousands of different origins, you're now making thousands requests from a single origin.

When caching responses for the sake of performance, be aware of where your query runs, for the sake of security. Depending on the query, you might or might not want to share your caches across requests.

## Conclusion

My concern isn't about moving to fullstack development. I've been there for over 15 years. My concern is about the hybrid nature that we're moving into. Code runs in both environments, and boundaries are there, but not clearly visible. It's easy to slip up because we're busy, or because we're missing something during refactor.

Our tools aren't ready for this. We don't have an isomorphic debugger that hits breakpoints on both environments, and we don't have an isomorphic console that merges log statements from client and server. Eslint is merely a linter for formatting, and TypeScript won't warn you about leaking variables either.

And all of the above can be learned. But it's so much more than "just adapt your mental model". It's new knowledge, and it'll make your job harder. If you believe it doesn't, then you're either missing the risks, or you're underselling yourselve.

Maybe it's time to stop calling it fullstack development. It's no longer enough to be proficient in both environments. We need to start thinking of it like a single environment, even tho our tools don't expose it that way. How does isomorphic development sound?
